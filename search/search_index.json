{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"datatui","text":"<p>A minimal, and fun, annotation tool for the terminal.</p> <p></p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install datatui\n</code></pre>"},{"location":"#scope","title":"Scope","text":"<p>The goal of this project is to offer a constrained and minimalistic alternative to full fledged web apps for data annotation. You can only use four labels: <code>yes</code>, <code>no</code>, <code>maybe</code>, and <code>skip</code>. Only having a few options forces you to keep the scope small, which usually does wonders for data quality. It is still pretty flexible though, so you can use it for more complex tasks if you want. Anything that you can render nicely in rich can be rendered in <code>datatui</code>. </p> <p>You only need a terminal, which also means that you can SSH into your cron server to have a look at some of your data.</p>"},{"location":"#examples","title":"Examples","text":""},{"location":"#custom-rich-rendering","title":"Custom <code>rich</code> rendering","text":"<p>Rich comes with a lot of features that allow you to easily customise the look of what you are annotating. You can learn more about constructing interfaces with rich on calmcode.io but we also provide a demo below that highlights how to add panels. </p> <p></p> <p>Here's the code that produces the above output. </p> <pre><code>from rich.panel import Panel\nimport json \nfrom datatui import datatui, new_batch\n\n\n# Read JSONL file \ndef generator():\n    with open(\"examples/arxiv.jsonl\", \"r\") as f:\n        for line in f:\n            yield json.loads(line)\n\n# Create a new batch, removes duplicates\nbatch = new_batch(generator(), cache_name=\"annotations\", collection_name=\"default\", limit=100)\n\nif __name__ == \"__main__\":\n    # Run a new annotation session. Notice how we customise the content_render\n    # function to use rich Panels and that we add a description/progress bar to \n    # the annotation task.\n    app = datatui(list(generator()), \n            cache_name=\"annotations\", \n            collection_name=\"default\",\n            pbar=True, \n            description=\"Does this sentence suggest the article is about a [bold]new dataset[/bold]?.\",\n            content_render=lambda x: Panel(x[\"text\"])\n    )\n    app.run()\n</code></pre> <p>By leveraging the <code>concent_render</code> function you can customise the look of your annotations as you see fit.</p>"},{"location":"#custom-rich-rendering-includes-images","title":"Custom <code>rich</code> rendering, includes images!","text":"<p>Thanks to a healthy ecosystem of <code>rich</code>, we can easily include images in our annotations via the rich-pixels plugin. Here is what that might look like.</p> <p></p> <p>To get this interface in <code>datatui</code> you would need to have a script like below. </p> <pre><code>from PIL import Image\nfrom rich.align import Align\nfrom rich_pixels import Pixels\nfrom datatui import datatui\nfrom pathlib import Path\n\nstream = [{\"path\": str(p)} for p in Path(\"examples/pokemons\").glob(\"*.png\")]\n\ndef render_image(ex):\n    with Image.open(ex[\"path\"]) as image:\n        resized_image = image.resize((40, 40), Image.LANCZOS)\n        return Align.center(Pixels.from_image(resized_image), vertical=\"middle\")\n\n\nif __name__ == \"__main__\":\n    app = datatui(stream, \n            cache_name=\"annotations\", \n            collection_name=\"pokemon\", \n            pbar=True, \n            description=\"Is this a fire pokemon?\",\n            content_render=render_image)\n    app.run()\n</code></pre> <p>Note that this script can also be found in the examples folder of the repository.</p>"},{"location":"#how-it-works","title":"How it works","text":"<p>Before an example is annotated it needs to be rendered. This is done by the <code>content_render</code> function.  This function assumes that the input is a dictionary and that the output is some sort of object that rich can render. </p> <p>Given a renderable example, we do some extra work to prevent duplicates and to keep track of which examples have been annotated. This is done using a combination of a hashing function and diskcache. If the hash of an example is not in the cache, the example is rendered and shown to the user. If the hash is in the cache, we simply skip it. After the annotation, the example is saved to the cache as JSON, together with the label that the user chose. </p> <p>There are two details worth mentioning here on top of this. </p> <ul> <li>You can pass a <code>cache_name</code> to the <code>datatui</code> function. This allows you to configure the folder where we store the SQLite DB with all the annotations. </li> <li>You can also pass a <code>collection_name</code> to the <code>datatui</code> function. This name is added to each annotated example, and can be used to keep different annotation tasks separate. For example, you might want to have separate collections for each label, while still storing everything in the same SQLite instance. Adding a collection name will influence the hashing, and you can also use it to export a specific subset later.</li> </ul>"},{"location":"#command-line-interface","title":"Command line interface","text":"<p>You can also use <code>datatui</code> from the terminal. While it is preferable to define a datatui session in a Python script, the CLI can also be used to start a simple  sessions. </p> <pre><code>python -m datatui annotate examples/arxiv.jsonl --cache annotations --collection default\n</code></pre> <p>In particular, the cli an be useful to write the annotations to disk using the <code>export</code> command. </p> <pre><code>python -m datatui export --file-out annotations.jsonl --collection pokemon\n</code></pre>"},{"location":"api/","title":"api","text":"<p>Add content key with background highlighting for entities to a stream of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>examples</code> <code>Iterable[Dict]</code> <p>An iterable of dictionaries, each containing 'text' and 'entity' keys.</p> required <p>Yields:</p> Name Type Description <code>Dict</code> <code>Iterable[Dict]</code> <p>A dictionary with the original keys and an additional 'content' key containing highlighted text.</p>"},{"location":"api/#datatui.datatui","title":"<code>datatui.datatui(input_stream, collection_name, cache_name='annotations', pbar=True, description=None, content_render=lambda x: x['text'])</code>","text":"<p>Main function to run the datatui application.</p> <p>Parameters:</p> Name Type Description Default <code>input_stream</code> <code>list</code> <p>A list of examples to annotate.</p> required <code>collection_name</code> <code>str</code> <p>The name of the collection for these examples.</p> required <code>cache_name</code> <code>str</code> <p>The name or path of the cache to use for storing annotations.</p> <code>'annotations'</code> <code>pbar</code> <code>bool</code> <p>Whether to display a progress bar. Defaults to True.</p> <code>True</code> <code>description</code> <code>str</code> <p>A description to display above each example. Defaults to None.</p> <code>None</code> <code>content_render</code> <code>function</code> <p>A function to render the content of each example. Defaults to lambda x: x['text'].</p> <code>lambda x: x['text']</code> <p>This function initializes and runs the DatatuiApp, which provides a text-based user interface for annotating examples. It uses the provided cache to store annotations and allows users to navigate through examples, annotating them as 'yes', 'no', 'maybe', or skipping them.</p>"},{"location":"api/#datatui.new_batch","title":"<code>datatui.new_batch(input_data, cache_name, collection_name, limit=150)</code>","text":"<p>Read examples from a JSONL file or an iterable of dictionaries and return only those not present in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>Union[str, Path, Iterable[Dict]]</code> <p>Path to a JSONL file (as string or Path object) or an iterable of dictionaries containing examples.</p> required <code>cache_name</code> <code>str</code> <p>Path to the cache directory.</p> required <code>collection_name</code> <code>str</code> <p>Name of the collection for these examples.</p> required <code>limit</code> <code>int</code> <p>Maximum number of uncached examples to return. If None, return all uncached examples.</p> <code>150</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: A list of examples that are not present in the cache, up to the specified limit.</p>"},{"location":"cli/","title":"CLI","text":""},{"location":"cli/#datatui","title":"<code>datatui</code>","text":"<p>Usage:</p> <pre><code>$ [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Commands:</p> <ul> <li><code>annotate</code>: Annotate and put some examples into the...</li> <li><code>count</code>: Count and pretty print the number of...</li> <li><code>export</code>: Export annotations from the cache.</li> </ul>"},{"location":"cli/#annotate","title":"<code>annotate</code>","text":"<p>Annotate and put some examples into the cache.</p> <p>Usage:</p> <pre><code>$ annotate [OPTIONS] EXAMPLES_PATH\n</code></pre> <p>Arguments:</p> <ul> <li><code>EXAMPLES_PATH</code>: [required]</li> </ul> <p>Options:</p> <ul> <li><code>--cache TEXT</code>: Cache path  [default: annotations]</li> <li><code>--collection TEXT</code>: Attach a collection name to each annotation  [default: default]</li> <li><code>--descr TEXT</code>: Add a description</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"cli/#count","title":"<code>count</code>","text":"<p>Count and pretty print the number of annotations per collection.</p> <p>Usage:</p> <pre><code>$ count [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--cache TEXT</code>: Cache path  [default: annotations]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"cli/#export","title":"<code>export</code>","text":"<p>Export annotations from the cache.</p> <p>Usage:</p> <pre><code>$ export [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--cache TEXT</code>: Cache path  [default: annotations]</li> <li><code>--collection TEXT</code>: Subset a collection</li> <li><code>--file-out TEXT</code>: Output file path</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"}]}